#!/bin/bash

# MANAN LYNX - Enhanced Advanced CLI Search Tool
# A comprehensive search interface for macOS/Linux terminal
# Version: 2.0 - Enhanced Edition
# Features: Smart path handling, improved search, custom editor integration

# Color definitions with enhanced palette
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
DIM='\033[2m'
UNDERLINE='\033[4m'
BLINK='\033[5m'
REVERSE='\033[7m'
NC='\033[0m' # No Color

# Enhanced color scheme for better UX
PRIMARY='\033[38;5;39m'    # Bright blue
SECONDARY='\033[38;5;208m' # Orange
SUCCESS='\033[38;5;46m'    # Bright green
WARNING='\033[38;5;226m'   # Bright yellow
ERROR='\033[38;5;196m'     # Bright red
ACCENT='\033[38;5;129m'    # Purple

# Global variables for state management
CURRENT_DIR=""
SEARCH_HISTORY=()
PREVIEW_ENABLED=true
EDITOR_COMMAND="nano"
CUSTOM_HEADER_NAME="MANAN LYNX"

# Initialize current directory
init_current_dir() {
    CURRENT_DIR=$(pwd)
    # Create search history directory if it doesn't exist
    mkdir -p "$HOME/.mlynx"
    touch "$HOME/.mlynx/history"
}

# Function to display enhanced ASCII header
show_header() {
    clear
    if command -v figlet >/dev/null 2>&1; then
        echo -e "${PRIMARY}${BOLD}"
        figlet -f slant "MANAN LYNX"
        echo -e "${NC}"
    else
        echo -e "${PRIMARY}${BOLD}MANAN LYNX${NC}"
    fi
    echo -e "${SECONDARY}${BOLD}                 Advanced CLI Search Tool - Enhanced Edition${NC}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${CYAN}üìÇ Current Directory: ${SUCCESS}${CURRENT_DIR}${NC}"
    echo -e "${CYAN}üîç Search History: ${DIM}$(tail -1 "$HOME/.mlynx/history" 2>/dev/null || echo "No recent searches")${NC}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
}

# Enhanced menu with better visual hierarchy
show_menu() {
    echo -e "\n${BOLD}${ACCENT}üöÄ MANAN LYNX Search Options:${NC}"
    echo -e "${PRIMARY}‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê${NC}"
    echo -e "${PRIMARY}‚îÇ${NC} ${SUCCESS}${BOLD}[D]${NC} Document Search      ${BLUE}üìÑ Search files by name/extension/pattern${NC}         ${PRIMARY}‚îÇ${NC}"
    echo -e "${PRIMARY}‚îÇ${NC} ${SUCCESS}${BOLD}[F]${NC} File Browser         ${BLUE}üìÅ Interactive file browser with preview${NC}          ${PRIMARY}‚îÇ${NC}"
    echo -e "${PRIMARY}‚îÇ${NC} ${SUCCESS}${BOLD}[I]${NC} Content Search       ${BLUE}üîç Search inside files with ripgrep${NC}               ${PRIMARY}‚îÇ${NC}"
    echo -e "${PRIMARY}‚îÇ${NC} ${SUCCESS}${BOLD}[C]${NC} Change Directory     ${BLUE}üìÇ Navigate to different folder${NC}                   ${PRIMARY}‚îÇ${NC}"
    echo -e "${PRIMARY}‚îÇ${NC} ${SUCCESS}${BOLD}[H]${NC} Search History       ${BLUE}üìã View and reuse previous searches${NC}               ${PRIMARY}‚îÇ${NC}"
    echo -e "${PRIMARY}‚îÇ${NC} ${SUCCESS}${BOLD}[E]${NC} Editor Settings      ${BLUE}‚öôÔ∏è  Configure custom editor${NC}                       ${PRIMARY}‚îÇ${NC}"
    echo -e "${PRIMARY}‚îÇ${NC} ${SUCCESS}${BOLD}[X]${NC} Delete Files/Folders ${BLUE}üóëÔ∏è  Remove files or directories${NC}                  ${PRIMARY}‚îÇ${NC}"
    echo -e "${PRIMARY}‚îÇ${NC} ${SUCCESS}${BOLD}[R]${NC} Refresh              ${BLUE}üîÑ Update current directory${NC}                      ${PRIMARY}‚îÇ${NC}"
    echo -e "${PRIMARY}‚îÇ${NC} ${SUCCESS}${BOLD}[Q]${NC} Quit                 ${BLUE}‚ùå Exit application${NC}                              ${PRIMARY}‚îÇ${NC}"
    echo -e "${PRIMARY}‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò${NC}"
    echo -e "\n${ACCENT}üí° Smart Search: Type anything else to search files & content directly${NC}"
    echo -e "${YELLOW}üìù Controls: ${DIM}‚Üë‚Üì Navigate | Enter: Select | Ctrl+P: Preview | Ctrl+R: Toggle Preview | ESC: Back${NC}"
}

# Enhanced dependency checker with better error handling
check_dependencies() {
    local missing_tools=()
    local optional_tools=()
    
    # Essential tools
    command -v rg >/dev/null 2>&1 || missing_tools+=("ripgrep")
    command -v fzf >/dev/null 2>&1 || missing_tools+=("fzf")
    
    # Optional but recommended tools
    command -v bat >/dev/null 2>&1 || optional_tools+=("bat")
    command -v fd >/dev/null 2>&1 || optional_tools+=("fd")
    command -v tree >/dev/null 2>&1 || optional_tools+=("tree")
    
    if [ ${#missing_tools[@]} -ne 0 ]; then
        echo -e "${ERROR}${BOLD}‚ùå Missing required tools:${NC}"
        printf "${RED}  - %s${NC}\n" "${missing_tools[@]}"
        echo -e "\n${WARNING}Please install missing tools:${NC}"
        echo -e "${CYAN}  macOS: ${WHITE}brew install ripgrep fzf${NC}"
        echo -e "${CYAN}  Linux: ${WHITE}sudo apt install ripgrep fzf${NC} ${DIM}(or equivalent)${NC}"
        exit 1
    fi
    
    if [ ${#optional_tools[@]} -ne 0 ]; then
        echo -e "${WARNING}üí° Optional tools for enhanced experience:${NC}"
        printf "${YELLOW}  - %s${NC}\n" "${optional_tools[@]}"
        echo -e "${CYAN}Install with: ${WHITE}brew install bat fd tree${NC}"
        echo -e "${DIM}Press any key to continue...${NC}"
        read -n 1 -s
    fi
}

# Enhanced document search with better pattern matching
document_search() {
    clear
    show_header
    echo -e "\n${BOLD}${SUCCESS}üìÑ Document Search${NC}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    
    echo -e "${CYAN}üéØ Search options:${NC}"
    echo -e "${ACCENT}[1]${NC} ${YELLOW}Filename pattern${NC}     ${DIM}(*.txt, report*, etc.)${NC}"
    echo -e "${ACCENT}[2]${NC} ${YELLOW}File extension${NC}       ${DIM}(pdf, js, py, etc.)${NC}"
    echo -e "${ACCENT}[3]${NC} ${YELLOW}Advanced regex${NC}       ${DIM}(complex patterns)${NC}"
    echo -e "${ACCENT}[4]${NC} ${YELLOW}Size-based search${NC}    ${DIM}(find large/small files)${NC}"
    echo -e "${ACCENT}[5]${NC} ${YELLOW}Modified time${NC}        ${DIM}(recent files)${NC}"
    echo -e "\n${MAGENTA}Enter choice (1-5) or press ESC to return:${NC}"
    
    local choice
    read -n 1 -s choice
    
    case $choice in
        1)
            echo -e "\n${CYAN}üìù Enter filename pattern:${NC}"
            read -r pattern
            if [[ -n "$pattern" ]]; then
                echo -e "\n${SUCCESS}üîç Searching for files matching: ${YELLOW}$pattern${NC}"
                echo -e "${DIM}$(date)${NC} - Pattern: $pattern" >> "$HOME/.mlynx/history"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                
                local count=0
                while IFS= read -r file; do
                    ((count++))
                    local size=$(ls -lh "$file" 2>/dev/null | awk '{print $5}')
                    local mod_time=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$file" 2>/dev/null || stat -c "%y" "$file" 2>/dev/null | cut -d' ' -f1-2)
                    echo -e "${BLUE}üìÑ ${SUCCESS}$(basename "$file")${NC} ${DIM}($size)${NC} ${MAGENTA}‚Üí${NC} ${CYAN}$file${NC}"
                    echo -e "   ${DIM}Modified: $mod_time${NC}"
                    [[ $count -ge 50 ]] && break
                done < <(find "$CURRENT_DIR" -type f -name "$pattern" 2>/dev/null)
                
                [[ $count -eq 0 ]] && echo -e "${ERROR}‚ùå No files found matching pattern${NC}"
                echo -e "\n${DIM}Found $count files${NC}"
            fi
            ;;
        2)
            echo -e "\n${CYAN}üìù Enter file extension:${NC}"
            read -r ext
            if [[ -n "$ext" ]]; then
                ext="${ext#.}" # Remove leading dot if present
                echo -e "\n${SUCCESS}üîç Searching for .$ext files...${NC}"
                echo -e "${DIM}$(date)${NC} - Extension: .$ext" >> "$HOME/.mlynx/history"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                
                local count=0
                while IFS= read -r file; do
                    ((count++))
                    local size=$(ls -lh "$file" 2>/dev/null | awk '{print $5}')
                    echo -e "${BLUE}üìÑ ${SUCCESS}$(basename "$file")${NC} ${DIM}($size)${NC} ${MAGENTA}‚Üí${NC} ${CYAN}$file${NC}"
                    [[ $count -ge 50 ]] && break
                done < <(find "$CURRENT_DIR" -type f -name "*.$ext" 2>/dev/null)
                
                [[ $count -eq 0 ]] && echo -e "${ERROR}‚ùå No .$ext files found${NC}"
                echo -e "\n${DIM}Found $count files${NC}"
            fi
            ;;
        3)
            echo -e "\n${CYAN}üìù Enter regex pattern:${NC}"
            read -r pattern
            if [[ -n "$pattern" ]]; then
                echo -e "\n${SUCCESS}üîç Searching with regex pattern...${NC}"
                echo -e "${DIM}$(date)${NC} - Regex: $pattern" >> "$HOME/.mlynx/history"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                
                local count=0
                while IFS= read -r file; do
                    ((count++))
                    echo -e "${BLUE}üìÑ ${SUCCESS}$(basename "$file")${NC} ${MAGENTA}‚Üí${NC} ${CYAN}$file${NC}"
                    [[ $count -ge 50 ]] && break
                done < <(find "$CURRENT_DIR" -type f -regex ".*$pattern.*" 2>/dev/null)
                
                [[ $count -eq 0 ]] && echo -e "${ERROR}‚ùå No files found matching regex${NC}"
                echo -e "\n${DIM}Found $count files${NC}"
            fi
            ;;
        4)
            echo -e "\n${CYAN}üìù Enter size criteria (+100M, -1M, etc.):${NC}"
            read -r size_criteria
            if [[ -n "$size_criteria" ]]; then
                echo -e "\n${SUCCESS}üîç Searching for files $size_criteria...${NC}"
                echo -e "${DIM}$(date)${NC} - Size: $size_criteria" >> "$HOME/.mlynx/history"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                
                local count=0
                while IFS= read -r file; do
                    ((count++))
                    local size=$(ls -lh "$file" 2>/dev/null | awk '{print $5}')
                    echo -e "${BLUE}üìÑ ${SUCCESS}$(basename "$file")${NC} ${DIM}($size)${NC} ${MAGENTA}‚Üí${NC} ${CYAN}$file${NC}"
                    [[ $count -ge 50 ]] && break
                done < <(find "$CURRENT_DIR" -type f -size "$size_criteria" 2>/dev/null)
                
                [[ $count -eq 0 ]] && echo -e "${ERROR}‚ùå No files found with size criteria${NC}"
                echo -e "\n${DIM}Found $count files${NC}"
            fi
            ;;
        5)
            echo -e "\n${CYAN}üìù Enter time criteria (-1 for 1 day, -7 for 1 week):${NC}"
            read -r time_criteria
            if [[ -n "$time_criteria" ]]; then
                echo -e "\n${SUCCESS}üîç Searching for files modified in last ${time_criteria#-} days...${NC}"
                echo -e "${DIM}$(date)${NC} - Modified: $time_criteria days" >> "$HOME/.mlynx/history"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                
                local count=0
                while IFS= read -r file; do
                    ((count++))
                    local mod_time=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$file" 2>/dev/null || stat -c "%y" "$file" 2>/dev/null | cut -d' ' -f1-2)
                    echo -e "${BLUE}üìÑ ${SUCCESS}$(basename "$file")${NC} ${DIM}($mod_time)${NC} ${MAGENTA}‚Üí${NC} ${CYAN}$file${NC}"
                    [[ $count -ge 50 ]] && break
                done < <(find "$CURRENT_DIR" -type f -mtime "$time_criteria" 2>/dev/null)
                
                [[ $count -eq 0 ]] && echo -e "${ERROR}‚ùå No recently modified files found${NC}"
                echo -e "\n${DIM}Found $count files${NC}"
            fi
            ;;
        $'\e'|$'\x1b')
            return 0
            ;;
        *)
            echo -e "\n${ERROR}‚ùå Invalid choice${NC}"
            ;;
    esac
    
    echo -e "\n${YELLOW}üí° Press any key to continue...${NC}"
    read -n 1 -s
}

# Enhanced file browser with custom editor integration
file_search() {
    clear
    show_header
    echo -e "\n${BOLD}${SUCCESS}üìÅ Interactive File Browser${NC}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${CYAN}üéÆ Controls: ${DIM}‚Üë‚Üì Navigate | Enter: Select | Ctrl+P: Preview | Ctrl+R: Toggle Preview | ESC: Return${NC}\n"
    
    # Enhanced fzf with better preview and controls
    local fzf_command="find '$CURRENT_DIR' -type f 2>/dev/null | fzf"
    fzf_command+=" --height=85%"
    fzf_command+=" --layout=reverse"
    fzf_command+=" --border=rounded"
    fzf_command+=" --info=inline"
    fzf_command+=" --header='üìÅ File Browser - $CURRENT_DIR'"
    fzf_command+=" --header-lines=0"
    fzf_command+=" --prompt='üîç Search: '"
    fzf_command+=" --color=header:italic"
    fzf_command+=" --bind='ctrl-p:toggle-preview'"
    fzf_command+=" --bind='ctrl-r:toggle-preview-wrap'"
    fzf_command+=" --bind='ctrl-u:preview-page-up'"
    fzf_command+=" --bind='ctrl-d:preview-page-down'"
    
    if command -v bat >/dev/null 2>&1; then
        fzf_command+=" --preview='bat --style=numbers --color=always --line-range :500 {}'"
    else
        fzf_command+=" --preview='head -50 {}'"
    fi
    
    fzf_command+=" --preview-window=right:50%:wrap"
    
    local selected_file
    selected_file=$(eval "$fzf_command")
    
    if [[ -n "$selected_file" ]]; then
        echo -e "\n${SUCCESS}‚úÖ Selected file: ${YELLOW}$selected_file${NC}"
        echo -e "\n${CYAN}üéØ Choose action:${NC}"
        echo -e "${ACCENT}[1]${NC} ${YELLOW}View content${NC}           ${DIM}(with syntax highlighting)${NC}"
        echo -e "${ACCENT}[2]${NC} ${YELLOW}Edit in custom editor${NC}  ${DIM}(current: $EDITOR_COMMAND)${NC}"
        echo -e "${ACCENT}[3]${NC} ${YELLOW}Copy path to clipboard${NC} ${DIM}(ready to paste)${NC}"
        echo -e "${ACCENT}[4]${NC} ${YELLOW}Open in default app${NC}    ${DIM}(system default)${NC}"
        echo -e "${ACCENT}[5]${NC} ${YELLOW}Show detailed info${NC}     ${DIM}(size, permissions, etc.)${NC}"
        echo -e "${ACCENT}[6]${NC} ${YELLOW}Search in this file${NC}    ${DIM}(content search)${NC}"
        
        local action
        read -n 1 -s action
        
        case $action in
            1)
                clear
                echo -e "${SUCCESS}üìñ Content of: ${YELLOW}$selected_file${NC}"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                if command -v bat >/dev/null 2>&1; then
                    bat "$selected_file"
                else
                    cat "$selected_file"
                fi
                ;;
            2)
                echo -e "\n${SUCCESS}üöÄ Opening in $EDITOR_COMMAND...${NC}"
                $EDITOR_COMMAND "$selected_file"
                ;;
            3)
                if command -v pbcopy >/dev/null 2>&1; then
                    echo "$selected_file" | pbcopy
                    echo -e "\n${SUCCESS}üìã Path copied to clipboard!${NC}"
                elif command -v xclip >/dev/null 2>&1; then
                    echo "$selected_file" | xclip -selection clipboard
                    echo -e "\n${SUCCESS}üìã Path copied to clipboard!${NC}"
                else
                    echo -e "\n${WARNING}‚ö†Ô∏è  Clipboard not available. Path: $selected_file${NC}"
                fi
                ;;
            4)
                if command -v open >/dev/null 2>&1; then
                    open "$selected_file"
                elif command -v xdg-open >/dev/null 2>&1; then
                    xdg-open "$selected_file"
                else
                    echo -e "\n${WARNING}‚ö†Ô∏è  Cannot open file in default app${NC}"
                fi
                echo -e "\n${SUCCESS}üöÄ File opened in default application!${NC}"
                ;;
            5)
                echo -e "\n${SUCCESS}üìä File Information:${NC}"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                ls -la "$selected_file"
                echo -e "\n${CYAN}File type:${NC}"
                file "$selected_file"
                if command -v wc >/dev/null 2>&1; then
                    echo -e "\n${CYAN}Line count:${NC}"
                    wc -l "$selected_file"
                fi
                ;;
            6)
                echo -e "\n${CYAN}üìù Enter search term:${NC}"
                read -r search_term
                if [[ -n "$search_term" ]]; then
                    echo -e "\n${SUCCESS}üîç Searching in file...${NC}"
                    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                    rg --color=always --line-number --context=3 "$search_term" "$selected_file" 2>/dev/null || echo -e "${ERROR}‚ùå No matches found${NC}"
                fi
                ;;
        esac
        
        echo -e "\n${YELLOW}üí° Press any key to continue...${NC}"
        read -n 1 -s
    fi
}

# Enhanced content search with proper ripgrep flags
inner_search() {
    while true; do
        clear
        show_header
        echo -e "\n${BOLD}${SUCCESS}üîç Content Search${NC}"
        echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"

        echo -e "${CYAN}üéØ Search modes:${NC}"
        echo -e "${ACCENT}[1]${NC} ${YELLOW}Show content matches${NC}     ${DIM}(default ripgrep with context)${NC}"
        echo -e "${ACCENT}[2]${NC} ${YELLOW}List matching files${NC}      ${DIM}(ripgrep -l flag)${NC}"
        echo -e "${ACCENT}[3]${NC} ${YELLOW}Interactive search${NC}       ${DIM}(fzf + ripgrep preview)${NC}"
        echo -e "${ACCENT}[4]${NC} ${YELLOW}Type-specific search${NC}     ${DIM}(search in specific file types)${NC}"
        echo -e "${ACCENT}[5]${NC} ${YELLOW}Case-insensitive${NC}         ${DIM}(ignore case)${NC}"
        echo -e "${ACCENT}[6]${NC} ${YELLOW}Regex search${NC}             ${DIM}(advanced patterns)${NC}"
        echo -e "\n${MAGENTA}Enter choice (1-6) or press ESC to return to main menu:${NC}"

        local choice
        read -n 1 -s choice

        # Check for ESC key
        if [[ "$choice" == $'\e' || "$choice" == $'\x1b' ]]; then
            return 0
        fi
    
    case $choice in
        1)
            echo -e "\n${CYAN}üìù Enter search term:${NC}"
            read -r search_term
            if [[ -n "$search_term" ]]; then
                echo -e "\n${SUCCESS}üîç Searching for: ${YELLOW}$search_term${NC}"
                echo -e "${DIM}$(date)${NC} - Content: $search_term" >> "$HOME/.mlynx/history"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                rg --color=always --heading --line-number --context=2 "$search_term" "$CURRENT_DIR" 2>/dev/null || echo -e "${ERROR}‚ùå No matches found${NC}"
            fi
            ;;
        2)
            echo -e "\n${CYAN}üìù Enter search term:${NC}"
            read -r search_term
            if [[ -n "$search_term" ]]; then
                echo -e "\n${SUCCESS}üîç Files containing: ${YELLOW}$search_term${NC}"
                echo -e "${DIM}$(date)${NC} - Files with: $search_term" >> "$HOME/.mlynx/history"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                local count=0
                while IFS= read -r file; do
                    ((count++))
                    local matches=$(rg --count "$search_term" "$file" 2>/dev/null || echo "0")
                    echo -e "${BLUE}üìÑ ${SUCCESS}$(basename "$file")${NC} ${DIM}($matches matches)${NC} ${MAGENTA}‚Üí${NC} ${CYAN}$file${NC}"
                done < <(rg --files-with-matches --color=never "$search_term" "$CURRENT_DIR" 2>/dev/null)
                [[ $count -eq 0 ]] && echo -e "${ERROR}‚ùå No files found containing the search term${NC}"
                echo -e "\n${DIM}Found $count files${NC}"
            fi
            ;;
        3)
            echo -e "\n${CYAN}üìù Enter search term:${NC}"
            read -r search_term
            if [[ -n "$search_term" ]]; then
                echo -e "\n${SUCCESS}üîç Interactive search results:${NC}"
                echo -e "${DIM}$(date)${NC} - Interactive: $search_term" >> "$HOME/.mlynx/history"
                echo -e "${CYAN}Use arrow keys, Enter to view, ESC to exit${NC}"
                
                local selected_file=$(rg --files-with-matches --color=never "$search_term" "$CURRENT_DIR" 2>/dev/null | fzf \
                    --height=80% \
                    --layout=reverse \
                    --border=rounded \
                    --info=inline \
                    --header="üîç Search Results for: $search_term" \
                    --preview="rg --color=always --context=5 --line-number '$search_term' {}" \
                    --preview-window=right:50%:wrap)

                if [[ -n "$selected_file" ]]; then
                    echo -e "\n${SUCCESS}‚úÖ Selected: ${YELLOW}$selected_file${NC}"
                    echo -e "${CYAN}Press Enter to edit, 'o' to open, 'c' to copy path, or any key to continue${NC}"
                    read -n 1 -s action
                    case $action in
                        ''|$'\n') $EDITOR_COMMAND "$selected_file" ;;
                        'o') [[ -x "$(command -v open)" ]] && open "$selected_file" || xdg-open "$selected_file" 2>/dev/null ;;
                        'c') echo "$selected_file" | pbcopy 2>/dev/null || echo "$selected_file" | xclip -selection clipboard 2>/dev/null ;;
                    esac
                fi
            fi
            ;;
        4)
            echo -e "\n${CYAN}üìù Enter file extension (e.g., py, js, txt):${NC}"
            read -r ext
            echo -e "${CYAN}üìù Enter search term:${NC}"
            read -r search_term
            if [[ -n "$search_term" && -n "$ext" ]]; then
                echo -e "\n${SUCCESS}üîç Searching in .$ext files for: ${YELLOW}$search_term${NC}"
                echo -e "${DIM}$(date)${NC} - Type $ext: $search_term" >> "$HOME/.mlynx/history"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                rg --color=always --heading --line-number --context=2 --type-add "custom:*.$ext" --type custom "$search_term" "$CURRENT_DIR" 2>/dev/null || echo -e "${ERROR}‚ùå No matches found in .$ext files${NC}"
            fi
            ;;
        5)
            echo -e "\n${CYAN}üìù Enter search term (case will be ignored):${NC}"
            read -r search_term
            if [[ -n "$search_term" ]]; then
                echo -e "\n${SUCCESS}üîç Case-insensitive search for: ${YELLOW}$search_term${NC}"
                echo -e "${DIM}$(date)${NC} - Case-insensitive: $search_term" >> "$HOME/.mlynx/history"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                rg --color=always --heading --line-number --context=2 --ignore-case "$search_term" "$CURRENT_DIR" 2>/dev/null || echo -e "${ERROR}‚ùå No matches found${NC}"
            fi
            ;;
        6)
            echo -e "\n${CYAN}üìù Enter regex pattern:${NC}"
            read -r pattern
            if [[ -n "$pattern" ]]; then
                echo -e "\n${SUCCESS}üîç Regex search for: ${YELLOW}$pattern${NC}"
                echo -e "${DIM}$(date)${NC} - Regex: $pattern" >> "$HOME/.mlynx/history"
                echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                rg --color=always --heading --line-number --context=2 --regex "$pattern" "$CURRENT_DIR" 2>/dev/null || echo -e "${ERROR}‚ùå No matches found${NC}"
            fi
            ;;
        \e'|\x1b')
            return 0
            ;;
        *)
            echo -e "\n${ERROR}‚ùå Invalid choice${NC}"
            ;;
    esac
    
    echo -e "\n${YELLOW}üí° Press any key to continue or ESC to return to main menu...${NC}"
        read -n 1 -s continue_key
        if [[ "$continue_key" == $'\e' || "$continue_key" == $'\x1b' ]]; then
            return 0
        fi
    done
}

# Enhanced directory navigation with smart features
change_directory() {
    clear
    show_header
    echo -e "\n${BOLD}${SUCCESS}üìÇ Directory Navigation${NC}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    
    echo -e "${CYAN}Current directory: ${SUCCESS}$CURRENT_DIR${NC}"
    echo -e "\n${CYAN}üéØ Navigation options:${NC}"
    echo -e "${ACCENT}[1]${NC} ${YELLOW}Browse directories${NC}      ${DIM}(interactive selection)${NC}"
    echo -e "${ACCENT}[2]${NC} ${YELLOW}Enter path manually${NC}     ${DIM}(type full path)${NC}"
    echo -e "${ACCENT}[3]${NC} ${YELLOW}Go to home directory${NC}    ${DIM}(~/\$HOME)${NC}"
    echo -e "${ACCENT}[4]${NC} ${YELLOW}Go up one level${NC}         ${DIM}(parent directory)${NC}"
    echo -e "${ACCENT}[5]${NC} ${YELLOW}Recent directories${NC}      ${DIM}(history-based)${NC}"
    echo -e "${ACCENT}[6]${NC} ${YELLOW}Bookmarks${NC}               ${DIM}(saved locations)${NC}"
    
    local choice
    read -n 1 -s choice
    
    case $choice in
        1)
            echo -e "\n${CYAN}üìÅ Select directory:${NC}"
            local new_dir
            if command -v fd >/dev/null 2>&1; then
                new_dir=$(fd --type d --max-depth 3 . "$CURRENT_DIR" 2>/dev/null | fzf \
                    --height=50% \
                    --layout=reverse \
                    --border=rounded \
                    --info=inline \
                    --header="üìÅ Select Directory" \
                    --preview="ls -la {}" \
                    --preview-window=right:40%)
            else
                new_dir=$(find "$CURRENT_DIR" -type d -maxdepth 3 2>/dev/null | fzf \
                    --height=50% \
                    --layout=reverse \
                    --border=rounded \
                    --info=inline \
                    --header="üìÅ Select Directory")
            fi
            
            if [[ -n "$new_dir" && -d "$new_dir" ]]; then
                CURRENT_DIR="$new_dir"
                echo -e "\n${SUCCESS}‚úÖ Changed to: ${YELLOW}$CURRENT_DIR${NC}"
            fi
            ;;
        2)
            echo -e "\n${CYAN}üìù Enter directory path:${NC}"
            read -r new_path
            # Handle tilde expansion
            new_path="${new_path/#\~/$HOME}"
            if [[ -d "$new_path" ]]; then
                CURRENT_DIR="$new_path"
                echo -e "${SUCCESS}‚úÖ Changed to: ${YELLOW}$CURRENT_DIR${NC}"
            else
                echo -e "${ERROR}‚ùå Directory not found: $new_path${NC}"
            fi
            ;;
        3)
            CURRENT_DIR="$HOME"
            echo -e "\n${SUCCESS}‚úÖ Changed to home directory: ${YELLOW}$CURRENT_DIR${NC}"
            ;;
        4)
            CURRENT_DIR="$(dirname "$CURRENT_DIR")"
            echo -e "\n${SUCCESS}‚úÖ Changed to parent directory: ${YELLOW}$CURRENT_DIR${NC}"
            ;;
        5)
            echo -e "\n${CYAN}üìã Recent directories:${NC}"
            # Simple history based on command history
            local recent_dirs=$(history | grep -E "cd |mlynx" | tail -10 | awk '{print $NF}' | sort -u)
            if [[ -n "$recent_dirs" ]]; then
                local selected_dir=$(echo "$recent_dirs" | fzf --height=30% --header="Recent Directories")
                if [[ -n "$selected_dir" && -d "$selected_dir" ]]; then
                    CURRENT_DIR="$selected_dir"
                    echo -e "${SUCCESS}‚úÖ Changed to: ${YELLOW}$CURRENT_DIR${NC}"
                fi
            else
                echo -e "${WARNING}‚ö†Ô∏è  No recent directories found${NC}"
            fi
            ;;
        6)
            echo -e "\n${CYAN}üìå Bookmarks:${NC}"
            local bookmarks_file="$HOME/.mlynx/bookmarks"
            if [[ -f "$bookmarks_file" ]]; then
                local selected_bookmark=$(cat "$bookmarks_file" | fzf --height=30% --header="Bookmarks")
                if [[ -n "$selected_bookmark" && -d "$selected_bookmark" ]]; then
                    CURRENT_DIR="$selected_bookmark"
                    echo -e "${SUCCESS}‚úÖ Changed to: ${YELLOW}$CURRENT_DIR${NC}"
                fi
            else
                echo -e "${WARNING}‚ö†Ô∏è  No bookmarks found${NC}"
                echo -e "${CYAN}üí° Add current directory to bookmarks? (y/n):${NC}"
                read -n 1 -s add_bookmark
                if [[ "$add_bookmark" == "y" ]]; then
                    echo "$CURRENT_DIR" >> "$bookmarks_file"
                    echo -e "\n${SUCCESS}‚úÖ Bookmark added!${NC}"
                fi
            fi
            ;;
    esac
    
    echo -e "\n${YELLOW}üí° Press any key to continue...${NC}"
    read -n 1 -s
}

# Search history functionality
search_history() {
    clear
    show_header
    echo -e "\n${BOLD}${SUCCESS}üìã Search History${NC}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"

    local history_file="$HOME/.mlynx/history"
    if [[ -f "$history_file" && -s "$history_file" ]]; then
        echo -e "${CYAN}üîç Recent searches:${NC}"

        # Show formatted history
        local formatted_history=$(tail -20 "$history_file" | awk -F' - ' '{print NR ". " $2}' | tac)

        if [[ -n "$formatted_history" ]]; then
            local selected_search=$(echo "$formatted_history" | fzf \
                --height=60% \
                --layout=reverse \
                --border=rounded \
                --info=inline \
                --header="Select a previous search to repeat"
            )

            if [[ -n "$selected_search" ]]; then
                # Extract search term (remove the number prefix)
                local search_term=$(echo "$selected_search" | sed 's/^[0-9]*\. [^:]*: //')
                echo -e "\n${SUCCESS}‚úÖ Selected search term: ${YELLOW}$search_term${NC}"
                echo -e "${CYAN}üí° Press Enter to repeat this search or any key to return${NC}"
                read -n 1 -s repeat_search
                if [[ "$repeat_search" == "" ]]; then
                    echo -e "\n${SUCCESS}üîç Repeating search for: ${YELLOW}$search_term${NC}"
                    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
                    rg --color=always --heading --line-number --context=2 "$search_term" "$CURRENT_DIR" 2>/dev/null || echo -e "${ERROR}‚ùå No matches found${NC}"
                    echo -e "\n${YELLOW}üí° Press any key to continue...${NC}"
                    read -n 1 -s
                fi
            fi
        fi
    else
        echo -e "${WARNING}‚ö†Ô∏è  No search history found${NC}"
        echo -e "${CYAN}üí° Your searches will be saved here for future reference${NC}"
    fi

    echo -e "\n${YELLOW}üí° Press any key to continue...${NC}"
    read -n 1 -s
}

# Editor settings configuration
editor_settings() {
    clear
    show_header
    echo -e "\n${BOLD}${SUCCESS}‚öôÔ∏è  Editor Settings${NC}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    
    echo -e "${CYAN}Current editor: ${SUCCESS}$EDITOR_COMMAND${NC}"
    echo -e "\n${CYAN}üéØ Available editors:${NC}"
    echo -e "${ACCENT}[1]${NC} ${YELLOW}nano${NC}          ${DIM}(simple, user-friendly)${NC}"
    echo -e "${ACCENT}[2]${NC} ${YELLOW}vim${NC}           ${DIM}(powerful, modal)${NC}"
    echo -e "${ACCENT}[3]${NC} ${YELLOW}emacs${NC}         ${DIM}(extensible, feature-rich)${NC}"
    echo -e "${ACCENT}[4]${NC} ${YELLOW}code${NC}          ${DIM}(Visual Studio Code)${NC}"
    echo -e "${ACCENT}[5]${NC} ${YELLOW}subl${NC}          ${DIM}(Sublime Text)${NC}"
    echo -e "${ACCENT}[6]${NC} ${YELLOW}atom${NC}          ${DIM}(Atom editor)${NC}"
    echo -e "${ACCENT}[7]${NC} ${YELLOW}Custom${NC}        ${DIM}(specify your own)${NC}"
    echo -e "${ACCENT}[8]${NC} ${YELLOW}Change Header Name${NC} ${DIM}(customize ASCII header)${NC}"
    
    local choice
    read -n 1 -s choice
    
    case $choice in
        1) EDITOR_COMMAND="nano" ;;
        2) EDITOR_COMMAND="vim" ;;
        3) EDITOR_COMMAND="emacs" ;;
        4) EDITOR_COMMAND="code" ;;
        5) EDITOR_COMMAND="subl" ;;
        6) EDITOR_COMMAND="atom" ;;
        7)
            echo -e "\n${CYAN}üìù Enter custom editor command:${NC}"
            read -r custom_editor
            if [[ -n "$custom_editor" ]]; then
                EDITOR_COMMAND="$custom_editor"
            fi
            ;;
        8)
            echo -e "\n${CYAN}üìù Enter custom header name:${NC}"
            read -r custom_header
            if [[ -n "$custom_header" ]]; then
                CUSTOM_HEADER_NAME="$custom_header"
            fi
            ;;
        *)
            echo -e "\n${ERROR}‚ùå Invalid choice${NC}"
            ;;
    esac
    
    # Save preferences
    echo "EDITOR_COMMAND='$EDITOR_COMMAND'" > "$HOME/.mlynx/config"
    echo "CUSTOM_HEADER_NAME='$CUSTOM_HEADER_NAME'" >> "$HOME/.mlynx/config"
    echo -e "\n${SUCCESS}‚úÖ Editor set to: ${YELLOW}$EDITOR_COMMAND${NC}"
    
    echo -e "\n${YELLOW}üí° Press any key to continue...${NC}"
    read -n 1 -s
}

# Smart search function for direct input
smart_search() {
    local input="$1"
    clear
    show_header
    echo -e "\n${BOLD}${SUCCESS}üß† Smart Search${NC}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    
    echo -e "${CYAN}Searching for: ${YELLOW}$input${NC}"
    echo -e "${DIM}$(date)${NC} - Smart: $input" >> "$HOME/.mlynx/history"
    
    # First search for files by name
    echo -e "\n${ACCENT}üìÑ Files matching name:${NC}"
    local file_count=0
    while IFS= read -r file; do
        ((file_count++))
        echo -e "${BLUE}üìÑ ${SUCCESS}$(basename "$file")${NC} ${MAGENTA}‚Üí${NC} ${CYAN}$file${NC}"
        [[ $file_count -ge 10 ]] && break
    done < <(find "$CURRENT_DIR" -type f -iname "*$input*" 2>/dev/null)
    
    [[ $file_count -eq 0 ]] && echo -e "${DIM}No files found matching name${NC}"
    
    # Then search for content
    echo -e "\n${ACCENT}üîç Content matches:${NC}"
    local content_matches=$(rg --files-with-matches --color=never "$input" "$CURRENT_DIR" 2>/dev/null | wc -l)
    if [[ $content_matches -gt 0 ]]; then
        echo -e "${SUCCESS}Found in $content_matches files${NC}"
        rg --color=always --heading --line-number --context=1 "$input" "$CURRENT_DIR" 2>/dev/null | head -50
    else
        echo -e "${DIM}No content matches found${NC}"
    fi
    
    echo -e "\n${YELLOW}üí° Press any key to continue...${NC}"
    read -n 1 -s
}

# Enhanced refresh function
refresh_directory() {
    local old_dir="$CURRENT_DIR"
    CURRENT_DIR=$(pwd)
    
    if [[ "$old_dir" != "$CURRENT_DIR" ]]; then
        echo -e "${SUCCESS}üîÑ Directory updated: ${YELLOW}$CURRENT_DIR${NC}"
    else
        echo -e "${SUCCESS}‚úÖ Directory refreshed: ${YELLOW}$CURRENT_DIR${NC}"
    fi
    
    # Show directory stats
    local file_count=$(find "$CURRENT_DIR" -maxdepth 1 -type f 2>/dev/null | wc -l)
    local dir_count=$(find "$CURRENT_DIR" -maxdepth 1 -type d 2>/dev/null | wc -l)
    echo -e "${CYAN}üìä Stats: ${file_count} files, ${dir_count} directories${NC}"
    
    sleep 1
}

# Load configuration
load_config() {
    local config_file="$HOME/.mlynx/config"
    if [[ -f "$config_file" ]]; then
        source "$config_file"
    else
        # Set defaults
        EDITOR_COMMAND="nano"
        PREVIEW_ENABLED=true
        CUSTOM_HEADER_NAME="MANAN LYNX"
    fi
}

# Delete functionality
delete_files() {
    clear
    show_header
    echo -e "\n${BOLD}${ERROR}üóëÔ∏è  Delete Files/Folders${NC}"
    echo -e "${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"

    echo -e "${CYAN}üéØ Delete options:${NC}"
    echo -e "${ACCENT}[1]${NC} ${YELLOW}Delete files${NC}           ${DIM}(select files to delete)${NC}"
    echo -e "${ACCENT}[2]${NC} ${YELLOW}Delete folders${NC}         ${DIM}(select folders to delete)${NC}"
    echo -e "${ACCENT}[3]${NC} ${YELLOW}Delete by pattern${NC}      ${DIM}(pattern-based deletion)${NC}"
    echo -e "\n${MAGENTA}Enter choice (1-3) or press ESC to return:${NC}"

    local choice
    read -n 1 -s choice

    case $choice in
        1)
            echo -e "\n${CYAN}üìÅ Select files to delete:${NC}"
            local selected_files=$(find "$CURRENT_DIR" -maxdepth 2 -type f 2>/dev/null | fzf \
                --multi \
                --height=70% \
                --layout=reverse \
                --border=rounded \
                --info=inline \
                --header="Select files to delete (use TAB for multi-select)" \
                --preview="ls -la {}")

            if [[ -n "$selected_files" ]]; then
                echo -e "\n${ERROR}‚ö†Ô∏è  WARNING: You are about to delete the following files:${NC}"
                echo "$selected_files" | while read -r file; do
                    echo -e "${RED}  - $file${NC}"
                done
                echo -e "\n${CYAN}Type 'DELETE' to confirm or any other key to cancel:${NC}"
                read -r confirmation
                if [[ "$confirmation" == "DELETE" ]]; then
                    echo "$selected_files" | while read -r file; do
                        if rm "$file" 2>/dev/null; then
                            echo -e "${SUCCESS}‚úÖ Deleted: $file${NC}"
                        else
                            echo -e "${ERROR}‚ùå Failed to delete: $file${NC}"
                        fi
                    done
                else
                    echo -e "${YELLOW}‚ùå Deletion cancelled${NC}"
                fi
            fi
            ;;
        2)
            echo -e "\n${CYAN}üìÅ Select folders to delete:${NC}"
            local selected_dirs=$(find "$CURRENT_DIR" -maxdepth 2 -type d 2>/dev/null | grep -v "^$CURRENT_DIR$" | fzf \
                --multi \
                --height=70% \
                --layout=reverse \
                --border=rounded \
                --info=inline \
                --header="Select folders to delete (use TAB for multi-select)" \
                --preview="ls -la {}")

            if [[ -n "$selected_dirs" ]]; then
                echo -e "\n${ERROR}‚ö†Ô∏è  WARNING: You are about to delete the following folders:${NC}"
                echo "$selected_dirs" | while read -r dir; do
                    echo -e "${RED}  - $dir${NC}"
                done
                echo -e "\n${CYAN}Type 'DELETE' to confirm or any other key to cancel:${NC}"
                read -r confirmation
                if [[ "$confirmation" == "DELETE" ]]; then
                    echo "$selected_dirs" | while read -r dir; do
                        if rm -rf "$dir" 2>/dev/null; then
                            echo -e "${SUCCESS}‚úÖ Deleted: $dir${NC}"
                        else
                            echo -e "${ERROR}‚ùå Failed to delete: $dir${NC}"
                        fi
                    done
                else
                    echo -e "${YELLOW}‚ùå Deletion cancelled${NC}"
                fi
            fi
            ;;
        3)
            echo -e "\n${CYAN}üìù Enter pattern for files to delete (e.g., *.tmp, *.log):${NC}"
            read -r pattern
            if [[ -n "$pattern" ]]; then
                local matching_files=$(find "$CURRENT_DIR" -name "$pattern" -type f 2>/dev/null)
                if [[ -n "$matching_files" ]]; then
                    echo -e "\n${ERROR}‚ö†Ô∏è  WARNING: Files matching pattern '$pattern':${NC}"
                    echo "$matching_files" | while read -r file; do
                        echo -e "${RED}  - $file${NC}"
                    done
                    echo -e "\n${CYAN}Type 'DELETE' to confirm or any other key to cancel:${NC}"
                    read -r confirmation
                    if [[ "$confirmation" == "DELETE" ]]; then
                        echo "$matching_files" | while read -r file; do
                            if rm "$file" 2>/dev/null; then
                                echo -e "${SUCCESS}‚úÖ Deleted: $file${NC}"
                            else
                                echo -e "${ERROR}‚ùå Failed to delete: $file${NC}"
                            fi
                        done
                    else
                        echo -e "${YELLOW}‚ùå Deletion cancelled${NC}"
                    fi
                else
                    echo -e "${WARNING}‚ö†Ô∏è  No files found matching pattern: $pattern${NC}"
                fi
            fi
            ;;
        $'\e'|$'\x1b')
            return 0
            ;;
        *)
            echo -e "\n${ERROR}‚ùå Invalid choice${NC}"
            ;;
    esac

    echo -e "\n${YELLOW}üí° Press any key to continue...${NC}"
    read -n 1 -s
}

# Enhanced main function with better input handling
main() {
    # Initialize
    init_current_dir
    load_config
    check_dependencies
    
    # Create exit handler
    trap 'echo -e "\n${YELLOW}üí° Use [Q] to quit properly${NC}"; sleep 1' INT
    
    # Main loop with improved input handling
    while true; do
        show_header
        show_menu
        
        echo -e "\n${MAGENTA}${BOLD}üéØ Enter your choice or search term:${NC}"
        read -r input
        
        # Convert to lowercase for case-insensitive matching
        local choice=$(echo "$input" | tr '[:upper:]' '[:lower:]')
        
        case "$choice" in
            "d"|"document"|"doc")
                document_search
                ;;
            "f"|"file"|"files"|"browser")
                file_search
                ;;
            "i"|"inner"|"content"|"search")
                inner_search
                ;;
            "c"|"change"|"cd"|"directory")
                change_directory
                ;;
            "h"|"history"|"hist")
                search_history
                ;;
            "e"|"editor"|"edit"|"settings")
                editor_settings
                ;;
            "x"|"delete"|"remove"|"del")
                delete_files
                ;;
            "r"|"refresh"|"reload")
                refresh_directory
                ;;
            "q"|"quit"|"exit")
                clear
                echo -e "${SUCCESS}${BOLD}üéâ Thank you for using MANAN LYNX Enhanced!${NC}"
                echo -e "${CYAN}Happy coding! üöÄ${NC}"
                exit 0
                ;;
            "")
                # Empty input, just refresh
                continue
                ;;
            *)
                # Smart search for any other input
                smart_search "$input"
                ;;
        esac
    done
}

# Installation function for zsh integration
install_mlynx() {
    local script_path="$0"
    local install_dir="$HOME/.local/bin"
    local zshrc_file="$HOME/.zshrc"
    
    # Create local bin directory if it doesn't exist
    mkdir -p "$install_dir"
    
    # Copy script to local bin
    cp "$script_path" "$install_dir/mlynx"
    chmod +x "$install_dir/mlynx"
    
    # Add to PATH in zshrc if not already present
    if ! grep -q "export PATH=\"\$HOME/.local/bin:\$PATH\"" "$zshrc_file" 2>/dev/null; then
        echo -e "\n# MANAN LYNX - Enhanced CLI Search Tool" >> "$zshrc_file"
        echo "export PATH=\"\$HOME/.local/bin:\$PATH\"" >> "$zshrc_file"
        echo -e "${SUCCESS}‚úÖ Added to PATH in $zshrc_file${NC}"
    fi
    
    # Create alias for easier access
    if ! grep -q "alias mlynx=" "$zshrc_file" 2>/dev/null; then
        echo "alias mlynx='$install_dir/mlynx'" >> "$zshrc_file"
        echo -e "${SUCCESS}‚úÖ Created alias 'mlynx'${NC}"
    fi
    
    echo -e "${SUCCESS}üéâ Installation complete!${NC}"
    echo -e "${CYAN}Run 'source ~/.zshrc' or restart your terminal${NC}"
    echo -e "${CYAN}Then use 'mlynx' command from anywhere${NC}"
}

# Check if running with install flag
if [[ "$1" == "--install" ]]; then
    install_mlynx
    exit 0
fi

# Run the main function
main